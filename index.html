<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            margin: 0;
            padding: 0;
        }
        #myCanvas{
            display: block;
            margin: auto;
            border:1px solid black;
            padding: 0;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600" height="600"></canvas>
</body>
<script>
    // 以上为显示设置
    // 以下为作业核心源代码
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext('2d');
    var newPixel = ctx.createImageData(1,1);

    var triangle = [[400,100],[450,100],[425,125]];
    var six = [[100,400],[130,430],[130,460],[100,490],[70,460],[70,430]];
    var arr4 = [{x:100,y:100},{x:200,y:100},{x:250,y:150},{x:200,y:200},{x:100,y:200},{x:50,y:150}]
    var matrixMultipy = function(matrix1,matrix2){
        if(matrix1[0].length != matrix2.length) return ;
        let result = new Array();
        let temp = new Array();
        let sum;
        for(let i = 0;i < matrix1.length;i++){
            temp.length = 0;
            for(let j = 0;j < matrix2[0].length;j++){
                sum = 0;
                for(let k = 0;k < matrix2.length;k++){
                    sum += matrix1[i][k]*matrix2[k][j];
                }
                temp.push(Math.round(sum));
            }
            result.push(temp.slice());
        }
        return result;
    }
    Uint8ClampedArray.prototype.colorHex = function () {
        let color = this;
        var strHex = "#";
        for (var i = 0; i < color.length; i++) {
            var hex = color[i].toString(16);
            if (hex === "0") {
                hex += hex;
            }
            strHex += hex;
        }
        return strHex;
    };
    String.prototype.colorRgb = function () {
    let color = this.toLowerCase();
        if (color.length === 4) {
            let colorNew = "#";
            for (let i = 1; i < 4; i += 1) {
                colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1));                }
            color = colorNew;
        }
        let colorChange = [];
        for (let i = 1; i < 7; i += 2) {
            colorChange.push(parseInt("0x" + color.slice(i, i + 2)));
        }
        return colorChange;
    };
    var BezierMaker = function(canvas, bezierCtrlNodesArr, color) {
        this.canvas = canvas
        this.ctx = this.canvas.getContext('2d')
        this.bezierCtrlNodesArr = bezierCtrlNodesArr ? bezierCtrlNodesArr : []
        this.color = color ? color: '#ffffff'
        this.bezierArr = []
    }
    BezierMaker.prototype.bezier = function(t) {
        var x = 0,
            y = 0,
            bezierCtrlNodesArr = this.bezierCtrlNodesArr,
            n = bezierCtrlNodesArr.length - 1,
            self = this
        bezierCtrlNodesArr.forEach(function(item, index) {
            if(!index) {
                x += item.x * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
                y += item.y * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
            } else {
                x += self.factorial(n) / self.factorial(index) / self.factorial(n - index) * item.x * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
                y += self.factorial(n) / self.factorial(index) / self.factorial(n - index) * item.y * Math.pow(( 1 - t ), n - index) * Math.pow(t, index) 
            }
        })
        return {
            x: x,
            y: y
        }
    }
    BezierMaker.prototype.drawBezier = function() {
        var nodeArr = this.bezierCtrlNodesArr  
        if(nodeArr.length === 2) {
            console.warn('Control nodes should be more then two!')
            var startNode = nodeArr[0],
                endNode = nodeArr[1]
            this.ctx.moveTo(startNode.x, startNode.y)
            this.ctx.lineTo(endNode.x, endNode.y)
            this.ctx.strokeStyle = this.color
            this.ctx.stroke()
        } 
        else if(nodeArr.length === 3) {
            var startNode = nodeArr[0],
                ctrlNode = nodeArr[1],
                endNode = nodeArr[2]
            this.ctx.beginPath()
            this.ctx.moveTo(startNode.x, startNode.y)
            this.ctx.quadraticCurveTo(ctrlNode.x, ctrlNode.y, endNode.x, endNode.y)
            this.ctx.strokeStyle = this.color
            this.ctx.stroke()
        } 
        else if(nodeArr.length === 4) {
            var startNode = nodeArr[0],
                ctrlNodeA = nodeArr[1],
                ctrlNodeB = nodeArr[2],
                endNode = nodeArr[3]
            this.ctx.beginPath()
            this.ctx.moveTo(startNode.x, startNode.y)
            this.ctx.bezierCurveTo(ctrlNodeA.x, ctrlNodeA.y, ctrlNodeB.x, ctrlNodeB.y, endNode.x, endNode.y)
            this.ctx.strokeStyle = this.color
            this.ctx.stroke()
        } 
        else {
            var self = this
            for(i = 0; i < 1; i+=0.01) {
                this.bezierArr.push(this.bezier(i))
            }
            this.bezierArr.forEach(function(obj, index) {
                if (index) {
                    var startX = self.bezierArr[index - 1].x,
                        startY = self.bezierArr[index - 1].y,
                        x = obj.x,
                        y = obj.y
                    self.ctx.beginPath()
                    self.ctx.moveTo(startX, startY)
                    self.ctx.lineTo(x, y)
                    self.ctx.strokeStyle = self.color
                    self.ctx.stroke()
                }
            })
        }
        
    }
    BezierMaker.prototype.factorial = function(num) {
        if (num <= 1) {
            return 1;
        } 
        else {
            return num * this.factorial(num - 1);
        }
    }
    var drawPixel = function(x,y,color){
        let newcolor = typeof(color)=='string'?color.colorRgb():color;
        newPixel.data[0] = newcolor[0];
        newPixel.data[1] = newcolor[1];
        newPixel.data[2] = newcolor[2];
        newPixel.data[3] = 255;
        ctx.putImageData(newPixel,x,y);
    }
    var drawLine = function(x0,y0,x1,y1,color){
        if(x0 > x1){
            let temp;
            temp=x0;x0=x1;x1=temp;
            temp=y0;y0=y1;y1=temp;
        }
        let a,b,d1,d2,d,x,y;
        if(x0==x1){
            x=x0,y=y0;
            if(y1 >= y0){
                y = y0;
                while(y<=y1){
                    drawPixel(x,y,color);
                    y++;
                }
            }
            else{
                y = y1;
                while(y <= y0){
                    drawPixel(x,y,color);
                    y++;
                }
            }
            return ;
        }
        if(Math.abs(y1-y0)<=Math.abs(x1-x0)){
            if(y1 >= y0){
                a=y0-y1;b=x1-x0;d=2*a+b;d1=2*a;d2=2*(a+b);x=x0;y=y0;
                drawPixel(x,y,color);
                while(x<x1){
                    if(d<0){
                        x++;y++;d+=d2;
                    }
                    else{
                        x++;d+=d1;
                    }
                    drawPixel(x,y,color);
                }
            }
            else{
                a=y0-y1;b=x1-x0;d=2*a-b;d1=2*a;d2=2*(a-b);x=x0;y=y0;
                drawPixel(x,y,color);
                while(x<x1){
                    if(d>=0){
                        x++;y--;d+=d2;
                    }
                    else{
                        x++;d+=d1;
                    }
                    drawPixel(x,y,color);
                }
            }
        }
        else{
            if(y1 >= y0){
                a=y0-y1;b=x1-x0;d=a+2*b;d1=2*b;d2=2*(a+b);x=x0;y=y0;
                drawPixel(x,y,color);
                while(y<y1){
                    if(d>0){
                        y++;x++;d+=d2;
                    }
                    else{
                        y++;d+=d1;
                    }
                    console.log(x,y);
                    drawPixel(x,y,color);
                }
            }
            else{
                a=y0-y1;b=x1-x0;d=-2*b+a;d1=-2*b;d2=2*(a-b);x=x0;y=y0;
                drawPixel(x,y,color);
                while(y>y1){
                    if(d<=0){
                        y--;x++;d+=d2;
                    }
                    else{
                        y--;d+=d1;
                    }
                    drawPixel(x,y,color);
                }
            }
        }
    }
    var drawCircle = function(x0,y0,r,color){
        let circlePoints = function(x,y,ccolor){
            drawPixel(x0+x,y0+y,ccolor);
            drawPixel(x0+y,y0+x,ccolor);
            drawPixel(x0-x,y0+y,ccolor);
            drawPixel(x0+y,y0-x,ccolor);
            drawPixel(x0+x,y0-y,ccolor);
            drawPixel(x0-y,y0+x,ccolor);
            drawPixel(x0-x,y0-y,ccolor);
            drawPixel(x0-y,y0-x,ccolor);
        }
        let x = 0,y = r,d = 1.25-r;
        circlePoints(x,y,color);
        while(x <= y){
            if(d < 0) d +=2*x+3;
            else{
                d +=2*(x-y)+5;
                y -= 1;
            }
            x += 1;
            circlePoints(x,y,color);
        }
    }
    var duobianxing = function(points,color,fillcolor){
        for(let i = 0;i < points.length-1;i++){
            drawLine(points[i][0],points[i][1],points[i+1][0],points[i+1][1],color);
        }
        drawLine(points[points.length-1][0],points[points.length-1][1],points[0][0],points[0][1],color);


        let x0=0,y0=0;
        for(let i = 0;i < points.length;i++) x0 += points[i][0];
        for(let i = 0;i < points.length;i++) y0 += points[i][1];
        x0/=points.length;y0 /= points.length;

        let stack = new Array();
        let boundaryFill4 = function(x,y,boundarycolor,newcolor){
            let xx,yy;
            stack.push(x,y);
            while(stack.length > 0){
                yy = stack.pop();
                xx = stack.pop();
                let color = ctx.getImageData(xx,yy,1,1).data.slice(0,3).colorHex(); 
                if(color != newcolor && color != boundarycolor){
                    drawPixel(xx,yy,newcolor);
                    stack.push(xx,yy-1);
                    stack.push(xx+1,yy);
                    stack.push(xx,yy+1);
                    stack.push(xx-1,yy);
                }
            }
        }
        boundaryFill4(parseInt(x0),parseInt(y0),color,fillcolor);
    }
    var bezier = function(canvas,points,color){
        let bezier0 = new BezierMaker(canvas,points,color);
        bezier0.drawBezier();
    }
    var rotate45 = function(points,color){
        let newPoints = new Array();
        let rotateMatrix = new Array();
        rotateMatrix.push(new Array(Math.cos(-Math.PI/4),Math.sin(-Math.PI/4)));
        rotateMatrix.push(new Array(-Math.sin(-Math.PI/4),Math.cos(-Math.PI/4)));
        for(let i = 0;i < points.length;i++){
            newPoints.push(matrixMultipy(new Array(points[i]),rotateMatrix));
        }
        duobianxing(newPoints.flat(1),color,"#000000");
    }
    window.onload = function(){
        if(canvas.getContext){
            //在这里进行具体的操作，例如下面两行代码是多边形的扫描转换以及旋转。
            duobianxing(six,"#000000","#000000");
            rotate45(six,"#000000","#000000");
        }
        else{
            alert("您的浏览器不支持canvas");
        }
    }
</script>
</html>